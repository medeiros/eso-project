1. Introdução ao Projeto

Nos dias atuais, poucas coisas são mais importantes para a Humanidade quanto a
questão da ecologia. Na proporção em que crescemos enquanto espécie, a projeção
média de crescimento da população mundial é de 9 bilhões de pessoas até 2050.
[WWF 2013] Esse crescimento populacional influi diretamente nas condições de
vida no planeta.

Desta forma, no que concerne à área de atuação da MotorBRAS, a redução no
controle de emissões de gás carbônico apresenta-se, mais do que nunca, como um
diferencial competitivo atraente. Países mais desenvolvidos estão prontos e
dispostos a investir em tecnologias para redução do consumo de CO2, de forma que
o risco no investimento em tecnologias ambientais apresenta-se como baixo, uma
vez que a demanda por novas tecnologias neste campo é cada vez mais atrativa. As
empresas que forem pioneiras no investimento de tecnologias ambientais que
influenciem a vida das pessoas terão uma ótima vantagem competitiva em relação
aos concorrentes. 

Este projeto visa agregar valor à intenção da MoToRBRAS de entrar no mercado de
carros elétricos como serviço até 2020. A proposta é a de agregar tecnologia ao
produto, de forma a cativar o consumidor em relação ao serviço e, assim, mitigar
o impacto do Homem no meio ambiente. Consequências diretas são a geração de uma
imagem positiva no mercado, bem como a conquista de uma posição de vanguarda e
liderança no mercado. 

Países desenvolvidos são favoráveis à ideia de aluguel de carros elétricos em
suas grandes cidades, como forma de locomoção barata e rápida das pessoas para
seu local de trabalho. Carros elétricos, sendo pequenos e de baixo consumo, são
altamente atrativos como um meio-termo entre os carros particulares e o
transporte público. 

O que este projeto propõe é tornar esse serviço ainda mais atrativo, através da
customização de cada carro, pelo uso de tecnologia de ponta. O diferencial é
permitir que o carro seja automaticamente customizado para o indivíduo. As
seguintes características serão agregadas aos carros elétricos:

• Reconhecimento de íris – uma maneira eficiente de identificar o
indivíduo para então iniciar o processo de customização de suas preferências;

• Integração com redes sociais – para que seja possível ao indivíduo ter
acesso a sua agenda, contatos, calendários e preferências musicais
instantaneamente; 

• Customizações físicas internas – preferências como temperatura do carro
(ajuste do ar condicionado) e posição do banco serão carregados de um servidor
central e aplicados diretamente ao veículo quando da identificação do indivíduo;
da mesma forma, alterações no veículo são salvas no servidor central como
preferências do indivíduo, para posterior aplicação numa nova viagem;

• Customizações físicas externas – da mesma forma como a parte interna do
carro poderá ser customizada com base nas preferências, a parte externa também
poderá, ainda que de forma mais restrita: apenas a cor do carro poderá ser
alterada de acordo com a preferência do indivíduo, neste momento;

• Carregamento automático do carro – o carro poderá ser automaticamente
recarregado assim que passar por determinados checkpoints espalhados pela
cidade. O custo com combustível é praticamente nulo.

Além das características acima citadas, outros aspectos devem ser considerados
para garantir o correto funcionamento de todo o processo, tais como:

• Segurança – um aspecto importante que deve ser considerado em todo o
projeto, tanto pelo aspecto de segurança da identidade do indivíduo quanto pela
segurança na execução das tecnologias físicas de customização e carregamento
automático, bem como pela segurança nas transações de aluguel do veículo;

• Controle cadastral – o gerenciamento da customização das preferências e
do pagamento pelo serviço são aspectos que também devem ser endereçados, de
forma que um sistema para controle cadastral dos clientes faz-se necessário.



2. Condições e Características Importantes



3. Disciplinas do SWEBOK

As disciplinas do SWEBOK serão aplicadas pelos times de desenvolvimento conforme
segue: 

3.1. Requisitos

Os requisitos de produto serão expressos por meio de uma especificação composta
de histórias [1], por ordem de prioridade, que são definições funcionais de alto
nível. O analista de requisitos será responsável por prover informações
detalhadas referentes às histórias aos demais membros do time, no momento de
estimativa da iteração e durante toda a iteração. Desta forma, cabe a este
profissional ter o entendimento dos detalhes das histórias. Será entregue, a
cada iteração, uma documentação que detalha os aspectos importantes de cada
história realizada. [verificar questao de prender o texto com o que vem abaixo
por “gancho” no fim do parágrafo]

Engenheiro de software com perfil mais técnico também precisará ser envolvido no
entendimento dos requisitos juntamente com o analista de requisitos, pois a
visão técnica que considera os requisitos não-funcionais deve ser analisada ao
mesmo tempo em que os requisitos surgem.

O tester também deve estar no levantamento de requisitos, para prover uma visão
mais funcional que permita que a definição da especificação seja definida de uma
forma funcional e testável.

Os analistas de requisito precisarão ter livre acesso aos stackholders (pessoal
de marketing e parte jurídica – que atuam como reguladores), que vão fornecer e
auxiliar na validação dos requisitos. Esse acesso deverá ser feito através de
entrevistas, onde podem-se fazer uso de protótipos pela técnica de DDD (mais do
que o rigor do UML) e exemplificação de cenários como formas de obter clareza
nos detalhes das histórias. Os modelos conceituais estão a cargo dos
entrevistadores, e não definem característica formal. Apenas é esperado que
sejam definidos cenários para cada história, de forma a guiar o time durante a
construção e permitir geração de validação automatizada dos requisitos.

Considerando a característica dinâmica da equipe de marketing, assume-se que os
requisitos são voláteis; a abordagem para mudanças é a de tentar incorporar o
máximo possível se a história permanecer a mesma, mas caso trate-se de outra
história, incorporar apenas na próxima iteração, como forma de não impactar o
time.

Uma arquitetura será definida com base no entendimento das primeiras histórias
da especificação (e com base em conhecimento da visão geral do projeto e
características de infra-estrutura da empresa), e evoluída durante todo o
projeto, apoiando-se em técnicas como refatoração e automatização de testes de
regressão.

Os requisitos serão validados através de testes de aceitação, de duas formas:
manual (na reunião de demonstração da iteração, quando os stackholders comparam
as histórias combinadas em relação ao funcionamento do sistema), e automatizada:
utilizando a técnica de BDD, cada cenário de cada história será vinculado a
métodos de teste durante a construção, de forma que cada execução da suite de
testes irá gerar um relatório que define se as histórias estão funcionando de
acordo com o esperado.

3.2. Design

No início do projeto (antes da primeira iteração), considerando a visão geral e
o entendimento dos requisitos de maior prioridade, o design de software
arquitetural (top-level) será definido por um engenheiro de software com perfil
sênior em desenvolvimento. Após isto, a cada iteração, o trabalho de design
detalhado será incorporado no trabalho dos desenvolvedores da equipe, de forma
que o design não será mais dissociado da construção, e sim será parte desta. O
engenheiro sênior em desenvolvimento pode definir design arquitetural para
futuras iterações, dependendo da necessidade, e trabalhar juntamente com o time
na definição do design detalhado, durante a iteração. 
O design arquitetural deverá ser documentado em alto nível, considerando
aspectos como estilo arquitetural sendo utilizado, forma de tratamento de
eventos, forma de lidar com concorrência, distribuição de componentes,
persistência de dados.

Já a responsabilidade de design detalhado cabe a todos os desenvolvedores do
time, e não será exigida documentação formal para tal, pois assume-se o conceito
de que o “código-fonte é o design”. Contudo, será necessário validar a qualidade
deste design, o que será feito através da elaboração de relatório de inspeção de
código a cada iteração, que deve considerar as questões do documento de design
arquitetural, além de técnicas de design, como: abstração, acoplamento, coesão,
decomposição, modularização, encapsulamento, separação de responsabilidades,
design patterns. 

O relatório será realizado pelo engenheiro de software da própria equipe que
agregar o papel de sênior, e deve ser entregue como um artefato da iteração
(“relatório de qualidade de design”). A responsabilidade pela veracidade do
documento é de toda a equipe.

Além deste relatório, a qualidade do design também será garantida através de:

• práticas diárias de DDD: para permitir uma modelagem do design alinhada
com as regras de negócio sendo utilizadas. O DDD faz uso de um diagrama
simplificado de classes para modelar o entendimento;

• práticas diárias de pair programming e TDD: que orientam o desenvolvedor
no sentido de escrever um código claro e seguindo o paradigma de orientação a
objetos;

• práticas automatizadas: análise estática de código, para garantir que
boas práticas de design estão sendo adotadas no código sendo escrito. Esta
prática não deve ser avaliada apenas no final da iteração, mas diariamente, por
todo o time.

Em relação às descrições estruturais, espera-se que o documento de arquitetura
defina diagramas de deployment, e é desejável que os diagramas de classes
simplificados que surgem da prática de DDD também sejam documentados (a ser
definido pelo time).

Para este projeto, a estratégia de design é baseada em design orientado a
objeto, por ser um modelo comumente difundido pelos membros do time e por ser
adequar ao projeto proposto.


3.3. Construção

Este projeto tratará design e construção de forma muito próxima. Os engenheiros
de software com perfil de programadores terão poder de definir o design
detalhado bem como a codificação, sempre orientados por um programador sênior e
pelo design arquitetural. O programador poderá, portanto, aplicar os fundamentos
de minimização de complexidade, antecipação de mudanças e construção para
verificação tanto em design quanto em construção, sem a necessidade de haver
distinções.

É esperado que o programador reduza a complexidade em tudo o que for fazer,
utilizando os melhores algoritmos e padrões. Também é esperado que o código seja
escrito de forma a permitir futuras modificações sem grande impacto (e para
isso, é exigido que a prática de TDD seja adotada, e o conceito de refatoração
seja entendido). Outras práticas que serão exigidas do programador são a escrita
de testes unitários e de integração. A verificação da adoção destas práticas
será realizada juntamente com a “validação de qualidade do design”, descrita no
tópico anterior. 

Também será exigido que o programador escreva testes de aceitação baseados em
BDD, contra cada história da especificação que implementa, para garantir que seu
código seja verificável. Estes testes serão executados diariamente, gerando
relatórios que indicam se o código é válido em relação ao esperado. 
Será exigido que o programador siga os padrões de desenvolvimento de código da
empresa, e a ferramenta de análise estática de código irá indicar se os padrões
estão sendo ignorados, diariamente, durante a iteração. Códigos não-conformes
devem ser corrigidos o mais rápido possível, no prazo máximo de duração da
iteração.

Não será exigido uso formal de UML; contudo, o time pode optar por utilizar UML
(bem como qualquer outra forma visual de design) para facilitar a comunicação
e/ou o entendimento de um dado objeto ou conjunto de objetos que precisa ser
criado ou alterado. 

O modelo de construção que será adotado neste projeto é o Scrum. Este modelo
iterativo trata a construção de forma concorrente a outras atividades de
desenvolvimento de software, como os requisitos, o design e os testes. Todas
estas atividades interagem juntamente nesta fase de construção; desta forma, o
planejamento da construção se dá iterativamente, envolvendo todas as atividades:
desde a fase de análise (com a definição dos requisitos da especificação como
histórias por ordem de prioridade, e o entendimento profundo destas através da
elaboração de cenários), passando por  uma estimativa para a iteração (onde time
discute e define quantas histórias da especificação podem ser realizadas,
considerando a prioridade) e pela construção propriamente dita (onde os
programadores geram código considerando design, os analistas documentam as
histórias e os testers validam as histórias contra o sistema conforme vão sendo
finalizadas), e finalizando na entrega (onde os stackholder validam, numa
reunião de demonstração, o sistema rodando, a documentação e demais artefatos
que tenham sido previamente combinados a serem entregues). Para medida das
iterações, são utilizadas as métricas já descritas nos tópicos anteriores, bem
como o próprio aval dos stackholders.


3.4. Testes

A verificação dinâmica dos testes será aplicada pelo engenheiro de software com
perfil de tester durante cada iteração, assim que uma data história for dada
como pronta pelos engenheiros de software com perfil de programadores. Para este
fim, os programadores devem liberar cada história pronta num servidor de testes.

A verificação, num primeiro momento, deve contemplar o conjunto de cenários da
história (teste de conformidade, ou teste funcional) e a análise dos relatórios
automatizados gerados pelo framework de BDD.

Como já dito, o tester deve participar na fase de levantamento de requisitos,
para auxiliar o analista na definição das histórias e cenários específicos;
neste ponto, em sua área de conhecimento, garante critérios de seleção e
adequação dos testes, bem como o objetivo e a efetividade dos testes. O ganho
adicional com qualidade vem do fato de considerar que os programadores escrevem
a aplicação partindo da mesma ótica, o que auxilia na redução de falhas de
comunicação e de entendimento.

Deseja-se que o tester tenha perfil de programador, no sentido de poder auxiliar
na revisão de testes unitários e de integração que os desenvolvedores tenham
criado. Considerando a característica de pair programming da equipe, pode até
mesmo auxiliar o programador nesta atividade. Contudo, esta atividade não é
obrigatória, sendo esperado que o foco do tester mais voltado ao aspecto
funcional do software. 

Outro aspecto em que o tester deve atuar é em testes de sistema, verificando se
diversos requisitos não-funcionais estão de acordo com o esperado (com o apoio
do documento de design arquitetural e dos programadores), além de analisar
aspectos como performance, stress, configuração, usabilidade. Espera-se que faça
uso de  ferramentas para automatizar tais testes, e que gere um relatório no
final de cada iteração, referente a estes testes específicos.

Os testes de regressão funcionais devem ser automatizados, cobrindo os aspectos
funcionais de maior importância (a serem definidos pelo próprio tester). Os
aspectos não-funcionais não são esperados em relação à regressão, pois sua
característica não sugere regressão, mas sim diagnóstico pontual.

O tester tem liberdade para decidir realizar testes estruturais, testes
exploratórios e demais técnicas de testes que julgar válidas na iteração. Estes
testes também precisam ser documentados em relatório, com justificativa e
resultados. Os testes precisam ser planejados no início da iteração, e tal
definição precisa também constar no relatório a ser entregue no final da
iteração.


3.5. Manutenção

A equipe que dará manutenção é a mesma que desenvolveu o produto. Desta forma,
qualquer nova requisição de modificação (evolução ou correção) deve ser definida
na especificação, seja alterando ou adicionando novos itens. Tal item, então,
precisa ser definido em forma de história e com prioridade, para ingressar numa
próxima iteração, seguindo o mesmo fluxo de um novo requisito. Desta forma,
incorporando correções no fluxo normal de desenvolvimento (e não após todo o
projeto ter terminado), procura-se eliminar o problema onde 80% do esforço de
manutenção é gasto em ações não corretivas. Neste caso, a manutenção acontece
enquanto o projeto ainda existe, e a prioridade fica a cargo dos stackholders. 

A evolução do software, portanto, será agregada durante o projeto de
desenvolvimento, cabendo apenas que haja um gerenciamento dos requisitos em
relação à prioridade. Como a equipe é a mesma, não há transição de conhecimento.
As manutenções corretivas, adaptativas e perfectivas irão entrar no fluxo normal
de desenvolvimento. Já espera-se que a manutenção preventiva seja um trabalho
implícito, resultante das práticas de qualidade e métricas nas fases de análise,
design e construção.

A definição de testes de regressão de outras fases também irá ajudar na
manutenção, definindo aspectos que não funcionam mais conforme esperado. Os
testes de aceitação automatizados com BDD também garantem a mesma regressão, mas
num nível mais alto: que as funcionalidades continuam válidas. 

Espera-se que toda a qualidade definida até o momento (com testes automatizados,
métricas e inspeção de design e análise) permitam que uma análise de impacto
gere sempre um baixo custo, e que haja uma alta capacidade de manutenibilidade. 

Após a finalização do projeto, uma equipe menor será designada para manter o
mesmo seguindo os mesmos princípios definidos até então, e com boa parte do
mesmo pessoal, de forma a facilitar a transmissão de conhecimento. Esta futura
equipe, poderá fazer uso dos documentos de especificação e design de arquitetura
e das documentações de testes para entender o sistema de um aspecto funcional, e
deverá estudar o código para entender um design mais detalhado. O esforço em
qualidade é pago aqui, pois o código deve estar escrito de forma que seja fácil
de entender e evoluir, de forma que a prática de engenharia reversa deve ser
desconsiderada. 

As práticas de inspeção de qualidade não devem deixar de existir, sob pena de
degradar a qualidade do código, de forma que a futura equipe de manutenção
precisará contar com um engenheiro de software com perfil sênior para estar
responsável por este aspecto (utilizando as ferramentas necessárias para tal
fim).


3.6. Gerenciamento de Configuração


3.7. Gerenciamento 

Justificar agile:	
http://audacium.com/wp-content/uploads/2012/08/Gartner-Agile-Maturity-Model.pdf
http://blogs.gartner.com/michael_blechar/2010/06/27/agile-methodologies-hype-or-reality/

Para que possa o projeto possa ser viabilizado, será necessária a montagem de
times de desenvolvimento. Seguindo a metodologia ágil de desenvolvimento SCRUM,
os times serão dispostos em células multidisciplinares, conforme segue:

• 1 celula de infraestrutura de comunicações – composta por 1 Product
Owner, 2 analistas de requisitos, 3 programadores e 1 tester

• 1 celula de customização lógica – composta por 1 Product Owner, 2
analistas de requisitos, 3 programadores e 1 tester

• 1 celula de customização física – composta por 1 Product Owner, 2
analistas de requisitos, 3 programadores e 1 tester

• 1 celula de gestão financeira e aluguel de carro – composta por 1
Product Owner, 2 analistas de requisitos, 3 programadores, 1 DBA e 1 tester 

Os analistas de requisitos precisam ter um forte entendimento do negócio
e das tendências da empresa, bem como acesso livre à pessoas da parte
operacional, da forma que um grupo de stackholders precisará ser definido.
Caberá aos Analistas, juntamente com os Product Owners de cada célula, a função
de interagir com os Stackholders e definir limites e restrições necessárias para
o andamento do projeto.

[colocar esse trecho na parte relativa a processo]

Esta abordagem de passagem de conhecimento por comunicação em detrimento da
passagem de conhecimento por documento previamente escrito pauta-se no exemplo
da filosofia do sistema de produção da Toyota, que sugere a redução de custo
pela eliminação de desperdício [1] (neste caso, o tempo). O trabalho
colaborativo do time baseado no entendimento prova-se mais produtivo do que a
construção de software baseado em documento previamente escrito. [citar refs]
[incorporar historia do inicio do scrum por schwartz tambem]

Esta abordagem de aumentar produtividade pela visão dos requisitos pautados em
confiança (mais do que por contratos burocráticos) torna-se mais viável pela
característica de que todas as partes envolvidas no projeto são internas à
MoToRBras.  



7. Considerações Gerais

O projeto aqui proposto caminha lado-a-lado com a tendência atual de preocupação
com o peso da vida humana na Terra. É assumido que os governos irão cada vez
mais investir em tecnologia para resolver tais problemas, ao invés de considerar
que haja uma mudança drástica de consciência no ser humano de forma geral. Este
projeto assume que nos próximos anos esta tendência irá se acentuar, de forma a
surgir uma oportunidade no mercado que favorecerá as empresas de vanguarda.
Nosso projeto caminha nesta direção. 



8. Conclusão

Este artigo procurou demonstrar como as diferentes disciplinas de engenharia de
software expostas no SWEBOK podem ser aplicadas na resolução de um problema
hipotético. A forma como as disciplinas do SWEBOK são abordadas tem um enfoque
particular em práticas ágeis de desenvolvimento de software, de forma a
demonstrar que tais práticas podem aplicadas dentro das orientações propostas
pelo SWEBOK.



9. Referências

WWF (2013). “WWF Living Planet Report: Human Impact”,
http://wwf.panda.org/about_our_earth/all_publications/living_planet_report/
2013_infographic/



