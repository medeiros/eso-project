\documentclass[12pt]{article}

\usepackage{sbc-template}

\usepackage{graphicx,url}

%\usepackage[brazil]{babel}   
\usepackage[latin1]{inputenc}  

     
\sloppy

\title{EcoCar\\ Carros para um Mundo Melhor}

\author{Daniel Assis Medeiros\inst{1}, Lindomar Goes Ferreira\inst{1}, Rodrigo Magalhães dos Santos\inst{1} }


\address{Instituto de Pesquisas Tecnológicas (IPT) -- Universidade Estadual de São Paulo
  (USP)\\
  São Paulo -- SP -- Brasil
}

\begin{document} 

\maketitle

\begin{abstract}
  This meta-paper describes the style to be used in articles and short papers
  for SBC conferences. For papers in English, you should add just an abstract
  while for the papers in Portuguese, we also ask for an abstract in
  Portuguese (``resumo''). In both cases, abstracts should not have more than
  10 lines and must be in the first page of the paper.
\end{abstract}
     
\begin{resumo} 
  Este meta-artigo descreve o estilo a ser usado na confecção de artigos e
  resumos de artigos para publicação nos anais das conferências organizadas
  pela SBC. É solicitada a escrita de resumo e abstract apenas para os artigos
  escritos em português. Artigos em inglês deverão apresentar apenas abstract.
  Nos dois casos, o autor deve tomar cuidado para que o resumo (e o abstract)
  não ultrapassem 10 linhas cada, sendo que ambos devem estar na primeira
  página do artigo.
\end{resumo}


\section{Introdução ao Projeto}

Nos dias atuais, poucas coisas são mais importantes para a Humanidade quanto a
questão da ecologia. Na proporção em que crescemos enquanto espécie, a projeção
média de crescimento da população mundial é de 9 bilhões de pessoas até 2050.
[WWF 2013] Esse crescimento populacional influi diretamente nas condições de
vida no planeta.

Desta forma, no que concerne à área de atuação da MotorBRAS, a redução no
controle de emissões de gás carbônico apresenta-se, mais do que nunca, como um
diferencial competitivo atraente. Países mais desenvolvidos estão prontos e
dispostos a investir em tecnologias para redução do consumo de CO2, de forma que
o risco no investimento em tecnologias ambientais apresenta-se como baixo, uma
vez que a demanda por novas tecnologias neste campo é cada vez mais atrativa. As
empresas que forem pioneiras no investimento de tecnologias ambientais que
influenciem a vida das pessoas terão uma ótima vantagem competitiva em relação
aos concorrentes.

Este projeto visa agregar valor à intenção da MoToRBRAS de entrar no mercado de
carros elétricos como serviço até 2020. A proposta é a de agregar tecnologia ao
produto, de forma a cativar o consumidor em relação ao serviço e, assim, mitigar
o impacto do Homem no meio ambiente. Consequências diretas são a geração de uma
imagem positiva no mercado, bem como a conquista de uma posição de vanguarda e
liderança no mercado.

Países desenvolvidos são favoráveis à ideia de aluguel de carros elétricos em
suas grandes cidades, como forma de locomoção barata e rápida das pessoas para
seu local de trabalho. Carros elétricos, sendo pequenos e de baixo consumo, são
altamente atrativos como um meio-termo entre os carros particulares e o
transporte público.

O que este projeto propõe é tornar esse serviço ainda mais atrativo, através da
customização de cada carro, pelo uso de tecnologia de ponta. O diferencial é
permitir que o carro seja automaticamente customizado para o indivíduo. As
seguintes características serão agregadas aos carros elétricos:

\begin{itemize}

\item Reconhecimento de íris --  uma maneira eficiente de identificar o
indivíduo para então iniciar o processo de customização de suas preferências;

\item Integração com redes sociais -- para que seja possível ao indivíduo ter
acesso a sua agenda, contatos, calendários e preferências musicais
instantaneamente; 

\item Customizações físicas internas -- preferências como temperatura do carro
(ajuste do ar condicionado) e posição do banco serão carregados de um servidor
central e aplicados diretamente ao veículo quando da identificação do indivíduo;
da mesma forma, alterações no veículo são salvas no servidor central como
preferências do indivíduo, para posterior aplicação numa nova viagem;

\item Customizações físicas externas -- da mesma forma como a parte interna do
carro poderá ser customizada com base nas preferências, a parte externa também
poderá, ainda que de forma mais restrita: apenas a cor do carro poderá ser
alterada de acordo com a preferência do indivíduo, neste momento;

\item Carregamento automático do carro -- o carro poderá ser automaticamente
recarregado assim que passar por determinados checkpoints espalhados pela
cidade. O custo com combustível é praticamente nulo.

\end{itemize}

Além das características acima citadas, outros aspectos devem ser considerados
para garantir o correto funcionamento de todo o processo, tais como:

\begin{itemize}

\item Segurança -- um aspecto importante que deve ser considerado em todo o
projeto, tanto pelo aspecto de segurança da identidade do indivíduo quanto pela
segurança na execução das tecnologias físicas de customização e carregamento
automático, bem como pela segurança nas transações de aluguel do veículo;

\item Controle cadastral -- o gerenciamento da customização das preferências e
do pagamento pelo serviço são aspectos que também devem ser endereçados, de
forma que um sistema para controle cadastral dos clientes faz-se necessário.

\end{itemize}

\section{Condições e Características Importantes}



\section{Disciplinas do SWEBOK}

As disciplinas do SWEBOK serão aplicadas pelos times de desenvolvimento conforme
segue: 

\subsection{Requisitos}

Os requisitos de produto serão expressos por meio de uma especificação composta
de histórias [1], por ordem de prioridade, que são definições funcionais de alto
nível. O analista de requisitos será responsável por prover informações
detalhadas referentes às histórias aos demais membros do time, no momento de
estimativa da iteração e durante toda a iteração. Desta forma, cabe a este
profissional ter o entendimento dos detalhes das histórias. Será entregue, a
cada iteração, uma documentação que detalha os aspectos importantes de cada
história realizada. [verificar questao de prender o texto com o que vem abaixo
por ``gancho'' no fim do parágrafo]

Engenheiro de software com perfil mais técnico também precisará ser envolvido no
entendimento dos requisitos juntamente com o analista de requisitos, pois a
visão técnica que considera os requisitos não-funcionais deve ser analisada ao
mesmo tempo em que os requisitos surgem.

O tester também deve estar no levantamento de requisitos, para prover uma visão
mais funcional que permita que a definição da especificação seja definida de uma
forma funcional e testável.

Os analistas de requisito precisarão ter livre acesso aos stakeholders (pessoal
de marketing e parte jurídica -- que atuam como reguladores), que vão fornecer e
auxiliar na validação dos requisitos. Esse acesso deverá ser feito através de
entrevistas, onde podem-se fazer uso de protótipos pela técnica de DDD [2] (mais do
que o rigor do UML) e exemplificação de cenários como formas de obter clareza
nos detalhes das histórias. Os modelos conceituais estão a cargo dos
entrevistadores, e não definem característica formal. Apenas é esperado que
sejam definidos cenários para cada história [3], de forma a guiar o time durante a
construção e permitir geração de validação automatizada dos requisitos. [4]

Considerando a característica dinâmica da equipe de marketing, assume-se que os
requisitos são voláteis; a abordagem para mudanças é a de tentar incorporar o
máximo possível se a história permanecer a mesma, mas caso trate-se de outra
história, incorporar apenas na próxima iteração, como forma de não impactar o
time.

Uma arquitetura será definida com base no entendimento das primeiras histórias
da especificação (e com base em conhecimento da visão geral do projeto e
características de infra-estrutura da empresa), e evoluída durante todo o
projeto [5], apoiando-se em técnicas como refatoração e automatização de testes de
regressão.

Os requisitos serão validados através de testes de aceitação, de duas formas:
manual (na reunião de demonstração da iteração, quando os stakeholders comparam
as histórias combinadas em relação ao funcionamento do sistema), e automatizada:
utilizando a técnica de BDD [6], cada cenário de cada história será vinculado a
métodos de teste durante a construção, de forma que cada execução da suite de
testes irá gerar um relatório que define se as histórias estão funcionando de
acordo com o esperado.

\subsection{Design}

No início do projeto (antes da primeira iteração), considerando a visão geral e
o entendimento dos requisitos de maior prioridade, o design de software
arquitetural (top-level) será definido por um engenheiro de software com perfil
sênior em desenvolvimento. Após isto, a cada iteração, o trabalho de design
detalhado será incorporado no trabalho dos desenvolvedores da equipe, de forma
que o design não será mais dissociado da construção, e sim será parte desta [7]. O
engenheiro sênior em desenvolvimento pode definir design arquitetural para
futuras iterações, dependendo da necessidade, e trabalhar juntamente com o time
na definição do design detalhado, durante a iteração. 
O design arquitetural deverá ser documentado em alto nível, considerando
aspectos como estilo arquitetural sendo utilizado, forma de tratamento de
eventos, forma de lidar com concorrência, distribuição de componentes,
persistência de dados.

Já a responsabilidade de design detalhado cabe a todos os desenvolvedores do
time, e não será exigida documentação formal para tal, pois assume-se o conceito
de que o ``código-fonte é o design'' [8]. Contudo, será necessário validar a qualidade
deste design, o que será feito através da elaboração de relatório de inspeção de
código a cada iteração, que deve considerar as questões do documento de design
arquitetural, além de técnicas de design, como: abstração, acoplamento, coesão,
decomposição, modularização, encapsulamento, separação de responsabilidades,
design patterns. 

O relatório será realizado pelo engenheiro de software da própria equipe que
agregar o papel de sênior, e deve ser entregue como um artefato da iteração
(``relatório de qualidade de design''). A responsabilidade pela veracidade do
documento é de toda a equipe.

Além deste relatório, a qualidade do design também será garantida através de:

\begin{itemize}
\item práticas diárias de DDD: para permitir uma modelagem do design alinhada
com as regras de negócio sendo utilizadas. O DDD faz uso de um diagrama
simplificado de classes para modelar o entendimento;

\item práticas diárias de pair programming e TDD [9]: que orientam o desenvolvedor
no sentido de escrever um código claro e seguindo o paradigma de orientação a
objetos;

\item práticas automatizadas: análise estática de código, para garantir que
boas práticas de design estão sendo adotadas no código sendo escrito [10]. Esta
prática não deve ser avaliada apenas no final da iteração, mas diariamente, por
todo o time.
\end{itemize}

Em relação às descrições estruturais, espera-se que o documento de arquitetura
defina diagramas de deployment, e é desejável que os diagramas de classes
simplificados que surgem da prática de DDD também sejam documentados (a ser
definido pelo time).

Para este projeto, a estratégia de design é baseada em design orientado a
objeto, por ser um modelo comumente difundido pelos membros do time e por ser
adequar ao projeto proposto.

\subsection{Construção}

Este projeto tratará design e construção de forma muito próxima. Os engenheiros
de software com perfil de programadores terão poder de definir o design
detalhado bem como a codificação, sempre orientados por um programador sênior e
pelo design arquitetural. O programador poderá, portanto, aplicar os fundamentos
de minimização de complexidade, antecipação de mudanças e construção para
verificação tanto em design quanto em construção, sem a necessidade de haver
distinções.

É esperado que o programador reduza a complexidade em tudo o que for fazer,
utilizando os melhores algoritmos e padrões. Também é esperado que o código seja
escrito de forma a permitir futuras modificações sem grande impacto (e para
isso, é exigido que a prática de TDD seja adotada, e o conceito de refatoração
seja entendido [11]). Outras práticas que serão exigidas do programador são a escrita
de testes unitários e de integração [12]. A verificação da adoção destas práticas
será realizada juntamente com a ``validação de qualidade do design'', descrita no
tópico anterior. 

Também será exigido que o programador escreva testes de aceitação baseados em
BDD, contra cada história da especificação que implementa, para garantir que seu
código seja verificável. Estes testes serão executados diariamente, gerando
relatórios que indicam se o código é válido em relação ao esperado. 
Será exigido que o programador siga os padrões de desenvolvimento de código da
empresa, e a ferramenta de análise estática de código irá indicar se os padrões
estão sendo ignorados, diariamente, durante a iteração. Códigos não-conformes
devem ser corrigidos o mais rápido possível, no prazo máximo de duração da
iteração.

Não será exigido uso formal de UML; contudo, o time pode optar por utilizar UML
(bem como qualquer outra forma visual de design) para facilitar a comunicação
e/ou o entendimento de um dado objeto ou conjunto de objetos que precisa ser
criado ou alterado. 

O modelo de construção que será adotado neste projeto é o Scrum. Este modelo
iterativo trata a construção de forma concorrente a outras atividades de
desenvolvimento de software, como os requisitos, o design e os testes. Todas
estas atividades interagem juntamente nesta fase de construção; desta forma, o
planejamento da construção se dá iterativamente, envolvendo todas as atividades:
desde a fase de análise (com a definição dos requisitos da especificação como
histórias por ordem de prioridade, e o entendimento profundo destas através da
elaboração de cenários), passando por  uma estimativa para a iteração (onde time
discute e define quantas histórias da especificação podem ser realizadas,
considerando a prioridade) e pela construção propriamente dita (onde os
programadores geram código considerando design, os analistas documentam as
histórias e os testers validam as histórias contra o sistema conforme vão sendo
finalizadas), e finalizando na entrega (onde os stakeholder validam, numa
reunião de demonstração, o sistema rodando, a documentação e demais artefatos
que tenham sido previamente combinados a serem entregues). Para medida das
iterações, são utilizadas as métricas já descritas nos tópicos anteriores, bem
como o próprio aval dos stakeholders.

\subsection{Testes}

A verificação dinâmica dos testes será aplicada pelo engenheiro de software com
perfil de tester durante cada iteração, assim que uma data história for dada
como pronta pelos engenheiros de software com perfil de programadores. Para este
fim, os programadores devem liberar cada história pronta num servidor de testes.

A verificação, num primeiro momento, deve contemplar o conjunto de cenários da
história (teste de conformidade, ou teste funcional) e a análise dos relatórios
automatizados gerados pelo framework de BDD.

Como já dito, o tester deve participar na fase de levantamento de requisitos,
para auxiliar o analista na definição das histórias e cenários específicos;
neste ponto, em sua área de conhecimento, garante critérios de seleção e
adequação dos testes, bem como o objetivo e a efetividade dos testes. O ganho
adicional com qualidade vem do fato de considerar que os programadores escrevem
a aplicação partindo da mesma ótica, o que auxilia na redução de falhas de
comunicação e de entendimento.

Deseja-se que o tester tenha perfil de programador, no sentido de poder auxiliar
na revisão de testes unitários e de integração que os desenvolvedores tenham
criado. Considerando a característica de pair programming da equipe, pode até
mesmo auxiliar o programador nesta atividade. Contudo, esta atividade não é
obrigatória, sendo esperado que o foco do tester mais voltado ao aspecto
funcional do software. 

Outro aspecto em que o tester deve atuar é em testes de sistema, verificando se
diversos requisitos não-funcionais estão de acordo com o esperado (com o apoio
do documento de design arquitetural e dos programadores), além de analisar
aspectos como performance, stress, configuração, usabilidade. Espera-se que faça
uso de  ferramentas para automatizar tais testes, e que gere um relatório no
final de cada iteração, referente a estes testes específicos.

Os testes de regressão funcionais devem ser automatizados, cobrindo os aspectos
funcionais de maior importância (a serem definidos pelo próprio tester). Os
aspectos não-funcionais não são esperados em relação à regressão, pois sua
característica não sugere regressão, mas sim diagnóstico pontual.

O tester tem liberdade para decidir realizar testes estruturais, testes
exploratórios e demais técnicas de testes que julgar válidas na iteração. Estes
testes também precisam ser documentados em relatório, com justificativa e
resultados. Os testes precisam ser planejados no início da iteração, e tal
definição precisa também constar no relatório a ser entregue no final da
iteração.

\subsection{Manutenção}

A equipe que dará manutenção é a mesma que desenvolveu o produto. Desta forma,
qualquer nova requisição de modificação (evolução ou correção) deve ser definida
na especificação, seja alterando ou adicionando novos itens. Tal item, então,
precisa ser definido em forma de história e com prioridade, para ingressar numa
próxima iteração, seguindo o mesmo fluxo de um novo requisito. Desta forma,
incorporando correções no fluxo normal de desenvolvimento (e não após todo o
projeto ter terminado), procura-se eliminar o problema onde 80% do esforço de
manutenção é gasto em ações não corretivas. Neste caso, a manutenção acontece
enquanto o projeto ainda existe, e a prioridade fica a cargo dos stakeholders. 

A evolução do software, portanto, será agregada durante o projeto de
desenvolvimento, cabendo apenas que haja um gerenciamento dos requisitos em
relação à prioridade. Como a equipe é a mesma, não há transição de conhecimento.
As manutenções corretivas, adaptativas e perfectivas irão entrar no fluxo normal
de desenvolvimento. Já espera-se que a manutenção preventiva seja um trabalho
implícito, resultante das práticas de qualidade e métricas nas fases de análise,
design e construção. No caso especial da construção, espera-se aplicação de 
refatoração e code review.

A definição de testes de regressão de outras fases também irá ajudar na
manutenção, definindo aspectos que não funcionam mais conforme esperado. Os
testes de aceitação automatizados com BDD também garantem a mesma regressão, mas
num nível mais alto: que as funcionalidades continuam válidas. 

Espera-se que toda a qualidade definida até o momento (com testes automatizados,
métricas e inspeção de design e análise) permitam que uma análise de impacto
gere sempre um baixo custo, e que haja uma alta capacidade de manutenibilidade. 

Após a finalização do projeto, uma equipe menor será designada para manter o
mesmo seguindo os mesmos princípios definidos até então, e com boa parte do
mesmo pessoal, de forma a facilitar a transmissão de conhecimento. Esta futura
equipe, poderá fazer uso dos documentos de especificação e design de arquitetura
e das documentações de testes para entender o sistema de um aspecto funcional, e
deverá estudar o código para entender um design mais detalhado. O esforço em
qualidade é pago aqui, pois o código deve estar escrito de forma que seja fácil
de entender e evoluir, de forma que a prática de engenharia reversa deve ser
desconsiderada. 

As práticas de inspeção de qualidade não devem deixar de existir, sob pena de
degradar a qualidade do código, de forma que a futura equipe de manutenção
precisará contar com um engenheiro de software com perfil sênior para estar
responsável por este aspecto (utilizando as ferramentas necessárias para tal
fim).

\subsection{Gerenciamento de Configuração}

Haverá uma gerência de configuração responsável pelo armazenamento de todos os 
artefatos gerados nas fases de requisitos, design, construção, testes e 
manutenção, bem como ferramentas necessárias a todas as áreas. O planejamento 
desta gerência deve considerar apenas elementos de software, descartando 
hardware e firmware por não serem aspectos cujo controle faz-se necessário. 
Não caberá à gerência de configuração definir regras sobre os artefatos 
gerados (com exceção do código-fonte gerado), de forma que os times podem 
versionar livremente; contudo, precisa prover mecanismos para auditar a 
informação (entende-se que estes mecanismos devem ser manuais, pela 
diversidade de artefatos que um dado time pode produzir). 

Em relação ao código-fonte gerado, a gerência de configuração precisará 
garantir sua qualidade através da análise estática de código com uso de 
ferramenta automatizada, de forma a garantir que o código está seguindo as boas 
práticas determinadas pela empresa. Relatórios desta medida de qualidade de 
código devem estar disponível para consulta a qualquer momento. O desenvolvedor 
deve possuir acesso a estas mesmas práticas, de forma a poder criar um código-
fonte de acordo com as práticas exigidas pela gerência de configuração. 

Outra característica que precisa ser considerada é a permissão de acesso. 
Apenas usuários de um dado projeto podem ter permissão de acesso ao repositório 
de informações do projeto, a não ser que a gerência diga o contrário. Assim 
sendo, é preciso haver uma forma automática de conceder acessos, tanto 
individuais quanto a grupos, de forma que um privilégio individual de um 
elemento num grupo possa sobrescrever seu privilégio enquanto membro do grupo.

Esta gerência também será responsável pela integração contínua: deverá prover 
e manter uma ferramenta de geração de builds automatizados, a ser executada 
diariamente (``integrando'' o código, agregando a execução de testes unitários e 
de integração gerados pelos programadores ao processo de build, gerando 
relatórios de métrica de cobertura de testes, e notificando todo o time no 
caso de builds e testes quebrados), bem como prover uma opção para geração 
de releases e deploy automático em servidor de testes (base da entrega
contínua). Com isto, espera-se agilidade na entrega do sistema para validação
pelos stakeholders. 

Portanto, é responsabilidade da gerência de configuração gerar os releases/
baselines. As baselines devem ser geradas a cada fim de iteração e os releases 
devem estar disponíveis para ser gerados sempre que a equipe de construção 
finalizar uma iteração, de forma que o ciclo de execução de trabalho deve estar 
alinhado com o desta equipe. Se o código-fonte não estiver conforme o validado 
pela análise estática de código e de acordo com as métricas de cobertura de 
testes geradas pela integração contínua, o release não poderá ser entregue. 
Cabe ao gerente de configuração a responsabilidade de alertar o time, de forma 
a evitar atrasos num entendimento tardio de que o release não poderá ser 
entregue por falta de qualidade.

\subsection{Gerenciamento}

Justificar agile:	
http://audacium.com/wp-content/uploads/2012/08/Gartner-Agile-Maturity-Model.pdf
http://blogs.gartner.com/michael\_blechar/2010/06/27/agile-methodologies-hype-or-reality/

Para que possa o projeto possa ser viabilizado, será necessária a montagem de
times de desenvolvimento. Seguindo a metodologia ágil de desenvolvimento SCRUM,
os times serão dispostos em células multidisciplinares, conforme segue:

\begin{itemize}

\item 1 celula de infraestrutura de comunicações -- composta por 1 Product
Owner, 2 analistas de requisitos, 3 programadores e 1 tester

\item 1 celula de customização lógica -- composta por 1 Product Owner, 2
analistas de requisitos, 3 programadores e 1 tester

\item 1 celula de customização física -- composta por 1 Product Owner, 2
analistas de requisitos, 3 programadores e 1 tester

\item 1 celula de gestão financeira e aluguel de carro -- composta por 1
Product Owner, 2 analistas de requisitos, 3 programadores, 1 DBA e 1 tester 
\end{itemize}

Os analistas de requisitos precisam ter um forte entendimento do negócio
e das tendências da empresa, bem como acesso livre à pessoas da parte
operacional, da forma que um grupo de stakeholders precisará ser definido.
Caberá aos Analistas, juntamente com os Product Owners de cada célula, a função
de interagir com os Stakeholders e definir limites e restrições necessárias para
o andamento do projeto.

[colocar esse trecho na parte relativa a processo]

Esta abordagem de passagem de conhecimento por comunicação em detrimento da
passagem de conhecimento por documento previamente escrito pauta-se no exemplo
da filosofia do sistema de produção da Toyota, que sugere a redução de custo
pela eliminação de desperdício [1] (neste caso, o tempo). O trabalho
colaborativo do time baseado no entendimento prova-se mais produtivo do que a
construção de software baseado em documento previamente escrito. [citar refs]
[incorporar historia do inicio do scrum por schwartz tambem]

Esta abordagem de aumentar produtividade pela visão dos requisitos pautados em
confiança (mais do que por contratos burocráticos) torna-se mais viável pela
característica de que todas as partes envolvidas no projeto são internas à
MoToRBras.  

\subsection{Considerações Gerais}

O projeto aqui proposto caminha lado-a-lado com a tendência atual de preocupação
com o peso da vida humana na Terra. É assumido que os governos irão cada vez
mais investir em tecnologia para resolver tais problemas, ao invés de considerar
que haja uma mudança drástica de consciência no ser humano de forma geral. Este
projeto assume que nos próximos anos esta tendência irá se acentuar, de forma a
surgir uma oportunidade no mercado que favorecerá as empresas de vanguarda.
Nosso projeto caminha nesta direção. 

\subsection{Conclusão}

Este artigo procurou demonstrar como as diferentes disciplinas de engenharia de
software expostas no SWEBOK podem ser aplicadas na resolução de um problema
hipotético. A forma como as disciplinas do SWEBOK são abordadas tem um enfoque
particular em práticas ágeis de desenvolvimento de software, de forma a
demonstrar que tais práticas podem aplicadas dentro das orientações propostas
pelo SWEBOK.

\section{Referências}


\bibliographystyle{sbc}
\bibliography{sbc-template}

\end{document}
